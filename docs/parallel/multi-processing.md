# 多进程编程

相比于多线程编程，多进程编程每个进程之间拥有更好的隔离性。一个进程崩溃基本不会导致其他进程也跟着崩溃。但是，独立性也带来了进程间共享数据困难的问题。使用多进程编程，可以像多线程编程一样，使用共享内存来完成进程间通信，也可以使用网络来进行通信。一般来说，如果需要程序运行在不同的机器上，那么就只能采用基于网络通信的多进程编程模型了，这也是常见的分布式系统的编程模型。多进程程序中，每个程序自己仍然可以使用多线程模型来提高 CPU 的利用率。

???+note "多线程和多进程" 
    多进程可以理解为互不共享资源的线程，反过来讲，线程也可以理解为共享资源的进程，它们的界限有时候并不是那么清楚。在不同操作系统上，有的会分开区别，创建线程和进程的开销也有区别。例如，Linux 中，`clone` 系统调用既可以用来创建进程，也可以用来创建线程，无论是 `fork` 还是 `pthread_create`，最终都会使用 `clone` 来创建进程/线程。线程在 Linux 中也叫做轻量进程（Light-weight Process, LWP）。

经典的使用多进程的程序有 nginx、PostgreSQL 等，其中 nginx 使用多进程的主要目的是负载均衡，不同的客户端连接将会分配到不同工作进程进行处理，一个工作进程会处理多个连接，而 PostgreSQL 则是为每一个客户端连接都开启新的进程，一个进程只处理一个连接。

在多线程编程中，由于线程之间共享资源，所以我们将注意力放到了如何避免共享资源出错，也就是避免竞态条件上。而在多进程编程里，我们首先需要解决如何让多个进程进行通信的问题。

## System V IPC

大多数操作系统，例如 Linux、Solaris 等都实现了 System V 中引入的 IPC API。

这套经典的 API 包含以下组成部分。其中前三种是支持最广泛的。

* 信号量（Semaphore）
* 消息队列（Message queue）
* 共享内存（Shared memory）
* 管道（Pipe）

### 信号量

和我们在多线程编程中介绍的 POSIX 信号量不同，System V 信号量更加复杂。

### 消息队列

### 共享内存

### 管道
