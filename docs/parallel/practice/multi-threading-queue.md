# 概览

支持多线程共享的队列是一种相当常见且重要的数据结构。正如我们在[《多线程编程》一节](https://liuhaohua.com/server-programming-guide/parallel/multi-threading/)中看到的那样，需要多线程的场景很多都会表现为一种生产者和消费者之间的协作关系。为了让生产者得以将数据传递给消费者，我们往往就需要一个先进先出（FIFO）的数据结构：队列。

在传统的单线程程序里，实现一个队列相当简单。然而在多线程的环境下，我们的队列必须满足以下额外的条件：

* 线程安全（thread-safe）

  多个线程在并发访问数据结构时，不会出现竞态条件，也不会造成数据结构内部状态的损坏。

* 异常安全（exception-safe）

  当一个线程调用数据结构提供的函数中途出现异常时，数据结构内部状态不会损坏，其他线程依然可以正常访问并得到正确的结果。并且也不会出现内存泄露。
  虽然异常安全在单线程场景下也很重要，但它值得在多线程场景中被再次强调。因为多线程下因异常安全造成的 bug 往往更加难以复现、排查，有时甚至会造成整个软件的崩溃。


在 C++ 中实现这样的一个队列，至少存在两种方法：基于互斥量的方法和基于原子量的方法。为了简单起见，我们在本节中只介绍基于互斥量的方法。读者可以参考本节的内容自行设计一个基于原子量的队列。

## 粗犷地使用互斥量的实现

C++ 的 STL 中已经提供了一个队列：`std::queue`，虽然它提供了一定的异常安全保证，但它不是线程安全的。要使用互斥量来让它变得线程安全，一个简单而粗犷的方式是使用互斥量包围暴露的所有函数：

```cpp
template<typename T>
class threadsafe_queue {
    std::queue<T> q;
    mutable std::mutex m;

public:
    threadsafe_queue() {}

    bool empty() const {
        std::scoped_lock lock(m);
        return q.empty();
    }

    void push(T element) {
        std::scoped_lock lock(m);
        q.push(std::move(element));
    }

    void pop(T& element) {
        if (!empty()) {
            std::scoped_lock lock(m);
            element = q.front();
            q.pop();
        }
    }
};
```

在上面的例子中，我们在各个函数中访问 `std::queue<T>` 对象之前都使用互斥量来确保了竞态条件不会发生，实现了一个带有基本功能的线程安全队列。虽然我们的实现基于具有一定异常安全性的 `std::queue<T>`，但是在包装的过程中有可能会引入一些新的破坏了异常安全性的地方。我们不妨对三个函数稍作检查。

* `empty()` 函数是异常安全的。`std::scoped_lock` 和 `std::mutex` 的 `lock()` 函数都提供了基本的异常安全保证，即在出现异常时互斥量仍处于有效状态，其他线程可以正常使用。

* `push()` 函数中调用的 `q.push()` 在底层会调用内部容器（通常是 `std::deque` 或 `std::list`）的 `push_back()` 函数。

  这里，STL 保证 `push_back() ` 在因为内存分配出错或者元素拷贝或移动出错时，会表现得就像函数没有被调用过一样。在出现异常后，C++ 会自动进行栈展开（stack unwinding），`lock` 的析构函数被调用，我们的锁因此被解开。
  
  因此，我们的 `push()` 函数是异常安全的。

* `pop()` 函数中，注意到 `pop` 函数中的 `element = q.front()` 语句，在这里我们对 `T` 类型的实例进行了拷贝复制操作。
  
  这里的 `T` 是由用户指定的类型，**并没有保证拷贝复制操作的过程不会出现异常**。当赋值操作不幸地出错时，C++ 自动进行栈展开，`lock` 析构函数被调用，锁被解开。因此，我们的 `pop()` 函数异常安全。

经过分析，上述代码中实现的 `threadsafe_queue` 是一个基本实现了线程安全和异常安全的队列数据结构。但是它对锁的使用太过粗犷，并没有提供理想的并发访问能力。一个例子是：**如果不加以保护，对 `push()` 和 `pop()` 的并发访问是否总会产生竞态条件？**

假设我们的 `std::queue` 底层使用了 `std::list` 作为内部容器，在队列内部拥有一个具有*一定数量*节点的链表时，一对并发的 `push()` 和 `pop()` 调用并不会让队列操作同一个链表节点，因此不会出现竞态条件。**如果我们能够让队列尽可能细致地识别何时应该使用互斥量，何时不应该使用，那么我们就能够进一步提升队列的并发访问性能。**同时，每次持有锁的时间越短，也能进一步提升性能。

为了打造具有更加精细的互斥量控制下的队列，我们接下来放弃对 `std::queue` 进行简单的包装，转而实现一个链表数据结构。

## 小结

在本节中我们

???+info
    对于多线程的生产者和消费者问题，使用队列并不是唯一的答案。对于一些支持 CSP （Communicating Sequential Processes）范式的语言来说，它们可以使用管道来解决这个问题。例如在 Go 语言中我们可以写出以下的代码：
