# 静态链接与动态链接

在[上一节的最后](procedure.md#链接)，我们看到了 `ld` 命令中含有 `-static` 这个参数。这告诉链接器，要使用**静态链接**的方式生成最后的可执行文件。既然有**静态链接**，就会有**动态链接**。本节将带你了解两者的差别。

## 静态链接

如果可执行文件以静态链接的方式链接，这就意味着在链接的时候，所有符号的二进制代码都会拷贝到最终的可执行文件中。例如，假如我们使用了 `printf` 这个函数，显然这个函数的二进制代码包含在系统库中，但是在链接的时候，也会拷贝到可执行文件里。

静态链接的做法比较简单，而且生成的二进制文件兼容性比较好，因为需要调用的函数都已经在文件里了，直接拷贝这个可执行文件到其他相同的操作系统执行，一般没有什么问题。当然，它也有缺点。

一是二进制的文件大小会变大。由于将所有用到的二进制代码都拷贝到了文件中，难免会让文件大小膨胀。

二是运行时占用内存会更多。我们知道，代码最终都是要加载到内存中执行的，二进制文件大小膨胀带来的一个后果就是运行的时候内存占用会更多。假如有十个运行的程序都用到了同一个库里的同样的函数，那么这十个程序会分别加载十次这个函数到内存中！

## 动态链接

为了解决静态链接带来的大小膨胀问题，人们提出了动态链接的方法，在编译的时候并不将库函数的二进制代码拷贝到可执行文件中，而是仅仅记录下来这个函数应该到什么文件中去寻找。运行的时候，需要调用这个函数的时候，再由操作系统来帮我们去加载对应的二进制代码。这种在运行时才真正加载二进制代码的方式就叫动态链接。而动态链接需要链接到共享库（Shared Library），Windows 上常见的 `.dll` 以及 Linux 上见到的 `.so` 文件就是程序运行的动态库了。这也是为什么有时候我们运行程序的时候，如果没有安装好运行时库，会提示“缺少 xxx.dll”而无法运行。

动态链接解决了静态链接的文件大小膨胀和内存占用增多的问题。一方面，可执行文件中不再包含二进制代码，另一方面，不同的进程可以共享同样的函数。例如，假如我们有十个进程都用到了 `printf` 这个函数，那么这十个进程可以共享内存中的同一份二进制代码，而不必重复加载代码到内存中，操作系统会处理共享的细节。

???+note "位置无关代码"

    由于动态链接，运行时二进制代码会被加载到内存中的哪个位置是完全不知道的。因此，动态链接库中的二进制代码必须被编译成位置无关的代码（Position-Independent Code）。例如，在静态链接中，我们可以指定函数 `printf` 的地址为 `0x1234`，之后需要调用 `printf` 时直接跳转到 `0x1234` 即可。但是动态链接的话，我们无法知道库会被加载到进程内存空间的哪个地址上，而且不同进程加载的地址可能完全不同。如果每次加载都需要修改库里的地址的话，开销会非常大。这时候我们就需要库函数不能依赖绝对地址，而是需要将所有地址编码为相对的地址。例如，可以将地址编码为相对于目前指令的地址的偏移。这样的代码就能在不做修改的情况下被加载到内存中的任何地址了。

???+note "动态链接库运行时加载的过程"

    在动态链接的二进制里，存在着 PLT（Procedure Linkage Table）与 GOT（Global Offset Table）两张表。在程序启动时，操作系统会去将动态库映射到进程的地址空间中，并将函数的地址填入 GOT 表中。动态链接的函数在调用的时候，会查找 GOT 中符号对应的地址并跳转过去。
    
    为了加快程序启动的速度，操作系统并不会一次就将所有函数加载进来，而是在 GOT 表中，填入 PLT 表的地址，在第一次调用函数时，不会直接调用到函数本身，而是 PLT 的默认代码。PLT 的代码会去调用操作系统的函数，加载对应符号的地址，并改写 GOT 表，将对应的地址从 PLT 默认表项改为函数实际的地址，实现懒加载的过程。

    这也体现了一个经典原则：计算机的所有问题都可以通过增加一层间接性来解决。


当然，动态链接也有它自己的问题。首先，由于调用函数需要先查表再跳转，运行的性能会有一些损失。而且，由于动态库必须编译为 PIC，所有的绝对寻址指令都会变为相对寻址指令，可能会导致运行效率下降，不过现代 CPU 对 PIC 都有较好的支持，可以忽略不计。另外，由于是在程序运行时才加载的库，这就需要在发布程序时，也要将程序依赖的动态库一并发布，如果只发布二进制，就需要用户自己安装好对应的运行时库，例如，我们在 Steam 安装游戏后，往往还需要安装 `Microsoft VC++ Redistributable`，其实就是安装这个游戏需要的动态库。最后，由于各个程序依赖的动态库版本可能不同，在安装时如果互相覆盖了动态库，就会造成严重的问题，甚至可能导致其他程序无法正常运行。另外，在程序卸载的时候，如果删除了一个动态库，那也会造成其他程序无法运行。

???+note "DLL Hell"
    在 Windows 上，曾经有过著名的 [DLL Hell](https://en.wikipedia.org/wiki/DLL_Hell) 问题。在早期，计算机的内存还比较小，所以使用动态链接库十分受欢迎。同时，微软在早期的 Windows 版本中，允许并鼓励软件安装动态库时，直接安装到系统共享的目录中。许多安装器并不会检查已有的 DLL 版本。这就很容易发生动态库互相覆盖的问题。而且由于微软的设计失误，DLL 并没有很好的兼容性，一个小小的改动可能会使 DLL 文件发生巨大的变化，使得程序无法正常运行。假如程序 A 使用了 2.0 版本的 DLL，程序 B 使用了 1.0 版本的 DLL，如果先启动程序 B，那么就会加载旧版 DLL 到内存中，等程序 A 启动的时候，操作系统为了节省内存，会将 1.0 版本的 DLL 映射给程序 A，这样也会导致程序 A 无法正常运行。

    Windows 后来也解决了这个问题，一个方法是保护系统的 DLL 不被修改，另一个方法是使用 [WinSxS](https://en.wikipedia.org/wiki/Side-by-side_assembly) 技术，在系统里存放 DLL 的不同版本，尽管应用程序还是会用同一个名字来加载 DLL，操作系统会检查版本并加载正确的二进制代码。还有一个办法就是直接在 DLL 文件名加上版本号，这样不同版本的 DLL 就不再是同一个 DLL 了。

    Linux 解决 DLL Hell 的办法有两个，一个是 `.so` 文件会带有版本号。其次，大多数 Linux 软件发布的时候都会提供源代码，用户可以自己编译。最后，大多数 Linux 发行版都带有包管理软件来管理软件的依赖，在安装软件时就检查依赖问题，避免了 DLL Hell。
