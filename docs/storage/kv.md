# KV 模型

KV 模型是最简单的存储模型之一，可以理解为可以持久化的 `std::map`。其实文件系统也可以理解为一个 KV：Key 是文件名，Value 是文件内容。通用的 KV 一般保存的是 `string` 到 `string` 的映射，其中的 `string` 不一定是需要纯文本，也可以是二进制的数据，可以理解为字节数组。

根据底层原理的不同，KV 提供的接口和性能也会有所不同。就像 `std::map` 和 `std::unordered_map` 一样，有的 KV 是基于有序数据结构，例如 LSMTree、B+Tree 等，来保证其中的 Key 是有序存储的，这样我们可以很方便的进行有序的范围扫描，但是为了维护 Key 的有序性，在插入和对单独一个 Key 查询时的时间复杂度则会有所上升。而基于哈希表的 KV 存储，则牺牲了有序范围扫描的功能，换取更高性能的单点查询、插入操作。不过，现在成熟的 KV 存储引擎即使底层采用了哈希存储，也同样会在内存中维护一份有序的 Key 列表，来提供范围查询的能力，这种方式可能会牺牲启动速度，因为每次启动都需要扫描一次磁盘中的文件来建立索引。

根据不同的使用场景，可以选择最适合的存储引擎。一般而言，需要考虑的因素有：

- 查询的方式，例如程序是针对某一个 Key 查询比较多（单点查询），还是会进行一定范围的扫描（范围查询），还是进行批量的 Key 查询（批量点查）
- 读/写的比例，例如程序是不是 99% 的时候都只是读取数据，而不会进行修改，或者是写入后基本不需要读取
- 读/写的延迟，例如注册用户的时候可能可以接受花好几秒来等待写入，但希望登录的时候几十毫秒就能读取数据
- 数据的容量，如果数据量太大，例如朋友圈、微博这种可能上百亿的数量，单机则无法满足需求，但如果自己写的小网站，数据量可能小到可以直接放在内存中
- 数据的热点分布，例如微博，很多访问到的微博都是最近一段时间发的，而发了一个星期或者更久的微博则基本很少被访问到

## RocksDB

目前最流行的单机 KV 存储引擎是 RocksDB，其前身是 Google 开发的 LevelDB。RocksDB 针对 SSD、多核等进行了各种性能优化，基本能满足大部分的需求。

## TiKV

基于 RocksDB 开发的分布式 KV 存储引擎，可以进行无限水平扩展，从而应付大量数据。