# 系统设计范式

前面提到的是在编写一个服务器程序时的微观的范式，而一个真正的后台系统通常还涉及更多的宏观系统设计范式。
## 分而治之

在数据量比较大，超过单机承载量的时候，通常会采用分片（Sharding）的方法来将数据划分成更小的互不相交的子集方便处理。通常来说，分片是通过某一个 Key 来作为切分的依据，并通过范围（Range）或者哈希（Hash）进行分片。

例如，用户量太大的时候，可以根据用户的 ID，来对用户数据进行分片。举个例子，如果采用范围分片，我们可以指定 ID 是 1~10000 的用户分配到机器 A，10001~20000 的用户分配到机器 B 等。如果采用哈希分片，可以将用户的 ID 哈希后取模，分配到指定机器上。范围分片可以进行高效的范围扫描，而哈希分片进行范围扫描的效率就差一些，需要到每台机器上去查询。哈希分片则有助于打散数据，避免数据热点集中在某台机器上。

在根据 Key 查询数据的时候，需要先计算出 Key 所在的分片，如果是静态分片，那么直接将上面提到的规则写到代码里即可。

当然，静态的分片并不实用，因为实际上我们的数据会不断的增删，而集群机器也可能发生变化，静态分片很难适应动态的变化。所以，分片也可以是动态的，假如我们往集群中新增了一台机器，那么我们当然希望一部分的数据可以迁移到这台新机器上，进一步均衡负载。而当某一台机器需要下线的时候，则需要将分片数据均匀地迁移回其他机器上。如果机器没有发生变动，但是随着数据的增删，某个机器上的分片数据量过多或者过少，同样需要进行平衡。

分片数据的动态迁移是一个比较复杂的问题，难点在于如何保证迁移过程中的数据可用以及一致性。

动态分片通常需要一个查询表来负责查询 Key 到分片的功能。例如，范围分片的话，需要保存以下信息：

```cpp
struct RangeInfo {
    int start;
    int end;
    int serverID;
};

vector<RangeInfo> ranges;
```

分片信息一般是有序存储的，这样可以使用二分查找快速定位，也可以使用搜索树来保存数据。

## 避免单点故障

### 主备模式

主备模式通常是由多台机器同时运行服务进程，但同一时刻最多只有一个进程正常对外服务，其他进程作为备份进程，只同步主进程的状态，而不响应请求。通常这种模式用于重要的少量的元数据的存储，例如上面提到的分片信息，就可以使用主备模式来保存。

### 对等模式

对等模式也是由多台机器同时运行服务进程，而且每一个进程的功能都是相同的，都可以对外服务，互相之间会同步数据。这种模式既能保证高可用，又可以实现负载均衡，不像主备模式中主节点承担了所有功能导致负载集中。但对等模式常常难以设计，开发复杂度相比主备模式会高很多。

## 计算存储分离

## 冷热分离

冷热分离和分片的想法类似，都是按照某种方法来将数据划分成子集。不过，数据分片，不同分片之间存储的机器配置通常是一样的。而冷热分离，则相当于给某些分片打上了不同属性，不同属性的数据根据特点存放到不同配置的机器上。例如，我们刷朋友圈，看到的几乎都是几天以内的照片，最好是马上就能加载出来，这部分照片占的容量比较小；几天以外的照片则很少被访问到，而且对访问速度要求也不高，但是它们加起来的占用空间非常大。提供高速访问的 SSD 容量小、价格高，而便宜量大的 HDD 访问速度则比较慢。根据这种特点，我们就可以将比较“旧”的照片存放到 HDD 存储，而将最近的照片存放到 SSD。同时，比较“旧”的照片可以使用压缩算法，用解压时间来换取更少的空间占用。

## 缓存

## 限流